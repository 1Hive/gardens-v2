// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import {GardensYDSStrategy} from "../../src/yds/GardensYDSStrategy.sol";
import {CVStreamingKeeper} from "../../src/automation/CVStreamingKeeper.sol";
import {CVStrategyHelpers} from "../CVStrategyHelpers.sol";
import {ProposalType} from "../../src/CVStrategy/ICVStrategy.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol";

/**
 * @title YDSStreamingIntegrationTest
 * @notice Integration tests for YDS → GDA → Streaming flow
 * @dev Tests complete Octant YDS pattern with Superfluid streaming
 * 
 * NOTE: Marked as abstract pending full test harness setup
 */
abstract contract YDSStreamingIntegrationTest is CVStrategyHelpers {
    using SuperTokenV1Library for ISuperToken;

    GardensYDSStrategy public yds;
    CVStreamingKeeper public keeper;
    ISuperfluidPool public gda;
    
    address public depositor1 = address(0x11);
    address public proposalBen1 = address(0x21);
    address public proposalBen2 = address(0x22);

    function setUp() public override {
        super.setUp();
        
        // Deploy mock GDA (in real scenario, use Superfluid's GDA factory)
        gda = _deployMockGDA();
        
        // Deploy YDS strategy with GDA as donation recipient
        yds = new GardensYDSStrategy(
            IERC20(address(token)),
            "Gardens YDS Test",
            "gYDS-TEST",
            address(0), // No external vault
            address(gda)  // GDA receives donation shares
        );
        
        // Set roles
        yds.setManagement(address(this));
        yds.setKeeper(address(this));
        
        // Register YDS in CVStrategy
        vm.prank(pool_admin());
        cvStrategy.setYDSStrategy(address(yds));
        
        // Initialize GDA in CVStrategy
        vm.prank(pool_admin());
        cvStrategy.initializeGDA(address(gda));
        
        // Enable streaming
        vm.prank(pool_admin());
        cvStrategy.setStreamingEnabled(true);
        
        // Deploy keeper
        keeper = new CVStreamingKeeper(
            address(cvStrategy),
            address(yds),
            86400,  // Report every 24h
            3600    // Rebalance every 1h
        );
        
        // Setup depositor
        token.mint(depositor1, 100000e18);
        vm.prank(depositor1);
        token.approve(address(yds), type(uint256).max);
    }

    /*//////////////////////////////////////////////////////////////
                        YDS → GDA FLOW TESTS
    //////////////////////////////////////////////////////////////*/

    function testYDSMintsDonationSharesToGDA() public {
        // Deposit into YDS
        vm.prank(depositor1);
        yds.deposit(10000e18, depositor1);
        
        // Simulate yield
        token.mint(address(yds), 1000e18);
        
        // Report
        (uint256 profit,) = yds.report();
        assertEq(profit, 1000e18);
        
        // GDA should have received donation shares
        uint256 gdaShares = yds.balanceOf(address(gda));
        assertGt(gdaShares, 0, "GDA received donation shares");
    }

    function testGDASharesRedeemableForUnderlying() public {
        // Generate donation shares
        vm.prank(depositor1);
        yds.deposit(10000e18, depositor1);
        token.mint(address(yds), 1000e18);
        yds.report();
        
        uint256 gdaShares = yds.balanceOf(address(gda));
        
        // GDA can redeem shares
        uint256 gdaBalanceBefore = token.balanceOf(address(gda));
        
        // Simulate GDA redeeming (in real scenario, rebalanceYieldStreams does this)
        vm.prank(address(gda));
        uint256 assets = yds.redeem(gdaShares, address(gda), address(gda));
        
        assertGt(assets, 0);
        assertEq(token.balanceOf(address(gda)) - gdaBalanceBefore, assets);
    }

    /*//////////////////////////////////////////////////////////////
                        STREAMING FLOW TESTS
    //////////////////////////////////////////////////////////////*/

    function testRebalanceRedeemsSharesAndStartsStreams() public {
        // Setup: Create proposals with support
        uint256 prop1 = _createProposalWithSupport(proposalBen1, 6000);
        uint256 prop2 = _createProposalWithSupport(proposalBen2, 4000);
        
        // Generate yield in YDS
        vm.prank(depositor1);
        yds.deposit(10000e18, depositor1);
        token.mint(address(yds), 1000e18);
        yds.report();
        
        // Verify donation shares minted
        uint256 gdaShares = yds.balanceOf(address(gda));
        assertGt(gdaShares, 0);
        
        // Advance blocks for conviction
        vm.roll(block.number + 1000);
        
        // Rebalance streams
        cvStrategy.rebalanceYieldStreams();
        
        // Check streams started
        (bool active1, uint128 units1,,) = cvStrategy.getStreamState(prop1);
        (bool active2, uint128 units2,,) = cvStrategy.getStreamState(prop2);
        
        assertTrue(active1, "Prop1 stream active");
        assertTrue(active2, "Prop2 stream active");
        
        // Units should be proportional to support (60/40 split)
        assertGt(units1, units2, "Prop1 has more units");
        assertApproxEqRel(units1, (units1 + units2) * 60 / 100, 0.05e18, "~60% units");
    }

    function testKeeperAutomatesFullCycle() public {
        // Setup proposals
        _createProposalWithSupport(proposalBen1, 10000);
        
        // Deposit into YDS
        vm.prank(depositor1);
        yds.deposit(10000e18, depositor1);
        
        // Simulate time passing and yield accrual
        vm.warp(block.timestamp + 1 days);
        token.mint(address(yds), 500e18);
        
        // Check upkeep
        (bool needed, bytes memory data) = keeper.checkUpkeep("");
        assertTrue(needed, "Upkeep should be needed");
        
        // Perform upkeep (both report and rebalance)
        keeper.performUpkeep(data);
        
        // Verify report was called
        assertEq(keeper.lastReport(), block.timestamp);
        
        // Verify rebalance was called  
        assertEq(keeper.lastRebalance(), block.timestamp);
        
        // Verify stream started
        (bool active,,,) = cvStrategy.getStreamState(1);
        assertTrue(active, "Stream should be active after keeper run");
    }

    function testConvictionChangesUpdateStreams() public {
        // Create proposals
        uint256 prop1 = _createProposalWithSupport(proposalBen1, 5000);
        uint256 prop2 = _createProposalWithSupport(proposalBen2, 5000);
        
        // Generate yield and start streams
        vm.prank(depositor1);
        yds.deposit(10000e18, depositor1);
        token.mint(address(yds), 1000e18);
        yds.report();
        
        vm.roll(block.number + 1000);
        cvStrategy.rebalanceYieldStreams();
        
        // Both should have ~50% units
        (,uint128 units1Before,,) = cvStrategy.getStreamState(prop1);
        (,uint128 units2Before,,) = cvStrategy.getStreamState(prop2);
        assertApproxEqAbs(units1Before, units2Before, 100, "Initial ~50/50 split");
        
        // Shift support: more to prop1
        vm.prank(pool_member2());
        _reallocateSupport(prop2, prop1, 3000);
        
        // Rebalance again
        vm.roll(block.number + 100);
        cvStrategy.rebalanceYieldStreams();
        
        // Units should now favor prop1
        (,uint128 units1After,,) = cvStrategy.getStreamState(prop1);
        (,uint128 units2After,,) = cvStrategy.getStreamState(prop2);
        
        assertGt(units1After, units1Before, "Prop1 units increased");
        assertLt(units2After, units2Before, "Prop2 units decreased");
        assertGt(units1After, units2After, "Prop1 > Prop2 after reallocation");
    }

    function testStreamStopsWhenProposalInactive() public {
        uint256 propId = _createProposalWithSupport(proposalBen1, 10000);
        
        // Start streaming
        _generateYieldAndRebalance();
        
        (bool activeBefore,,,) = cvStrategy.getStreamState(propId);
        assertTrue(activeBefore);
        
        // Cancel proposal
        vm.prank(pool_admin());
        cvStrategy.cancelProposal(propId);
        
        // Rebalance should stop stream
        cvStrategy.rebalanceYieldStreams();
        
        (bool activeAfter,,,) = cvStrategy.getStreamState(propId);
        assertFalse(activeAfter, "Stream stopped for inactive proposal");
    }

    /*//////////////////////////////////////////////////////////////
                            HELPERS
    //////////////////////////////////////////////////////////////*/

    function _deployMockGDA() internal returns (ISuperfluidPool) {
        // Deploy mock GDA for testing
        // In production, use Superfluid's actual GDA factory
        return ISuperfluidPool(address(new MockGDA()));
    }

    function _createProposalWithSupport(address beneficiary, uint256 support)
        internal
        returns (uint256 proposalId)
    {
        // Create proposal (simplified - would use actual proposal creation)
        proposalId = 1; // Mock
        
        // Allocate support
        // _allocateSupport(proposalId, support, pool_member1());
    }

    function _reallocateSupport(uint256 fromProposal, uint256 toProposal, uint256 amount) internal {
        // Remove from one, add to another
        // Implementation would use CVAllocationFacet
    }

    function _generateYieldAndRebalance() internal {
        vm.prank(depositor1);
        yds.deposit(10000e18, depositor1);
        
        token.mint(address(yds), 1000e18);
        yds.report();
        
        vm.roll(block.number + 1000);
        cvStrategy.rebalanceYieldStreams();
    }
}

/**
 * @notice Mock GDA for testing
 * @dev Simplified version - real GDA is much more complex
 */
contract MockGDA {
    mapping(address => uint128) public memberUnits;
    
    function updateMemberUnits(address member, uint128 units) external {
        memberUnits[member] = units;
    }
    
    function getMemberUnits(address member) external view returns (uint128) {
        return memberUnits[member];
    }
}



// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import {GardensYDSStrategy} from "../../src/yds/GardensYDSStrategy.sol";
import {CVStrategy} from "../../src/CVStrategy/CVStrategy.sol";
import {CVStrategyHelpers} from "../CVStrategyHelpers.sol";
import {CVParams, ProposalType, PointSystem, PointSystemConfig} from "../../src/CVStrategy/ICVStrategy.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title YDSIntegrationTest
 * @notice Integration tests for GardensYDSStrategy with CVYDSFacet
 * @dev Tests complete flow: YDS strategy → donation shares → CVYDSFacet → distribution
 * 
 * NOTE: Marked as abstract pending full test harness setup
 */
abstract contract YDSIntegrationTest is CVStrategyHelpers {
    
    GardensYDSStrategy public yds;
    
    address public depositor1 = address(0x11);
    address public depositor2 = address(0x12);
    address public proposalBeneficiary1 = address(0x21);
    address public proposalBeneficiary2 = address(0x22);
    
    function setUp() public override {
        super.setUp();
        
        // Deploy GardensYDSStrategy with CVStrategy as donation recipient
        yds = new GardensYDSStrategy(
            IERC20(address(token)),
            "Gardens YDS Test",
            "gYDS-TEST",
            address(0), // No external vault for simplicity
            address(cvStrategy) // CVStrategy receives donation shares
        );
        
        // Set management and keeper
        yds.setManagement(address(this));
        yds.setKeeper(address(this));
        
        // Register YDS strategy in CVStrategy
        vm.prank(pool_admin());
        cvStrategy.setYDSStrategy(address(yds));
        
        // Setup test depositors with tokens
        token.mint(depositor1, 100000e18);
        token.mint(depositor2, 100000e18);
        
        vm.prank(depositor1);
        token.approve(address(yds), type(uint256).max);
        
        vm.prank(depositor2);
        token.approve(address(yds), type(uint256).max);
    }
    
    /*//////////////////////////////////////////////////////////////
                        BASIC INTEGRATION TESTS
    //////////////////////////////////////////////////////////////*/
    
    function testCVStrategyReceivesDonationShares() public {
        // Depositor1 deposits into YDS
        vm.prank(depositor1);
        yds.deposit(10000e18, depositor1);
        
        // Simulate yield (10%)
        token.mint(address(yds), 1000e18);
        
        // Report generates donation shares
        (uint256 profit,) = yds.report();
        assertEq(profit, 1000e18);
        
        // CVStrategy should have donation shares
        uint256 cvStrategyShares = yds.balanceOf(address(cvStrategy));
        assertGt(cvStrategyShares, 0, "CVStrategy should have donation shares");
    }
    
    function testCVYDSFacetRedeemsShares() public {
        // Setup: deposit and generate yield
        vm.prank(depositor1);
        yds.deposit(10000e18, depositor1);
        
        token.mint(address(yds), 1000e18);
        yds.report();
        
        uint256 sharesBefore = yds.balanceOf(address(cvStrategy));
        uint256 cvBalanceBefore = token.balanceOf(address(cvStrategy));
        
        // CVYDSFacet harvests (redeems donation shares)
        cvStrategy.harvestYDS();
        
        // Shares should be redeemed
        uint256 sharesAfter = yds.balanceOf(address(cvStrategy));
        assertEq(sharesAfter, 0, "Shares redeemed");
        
        // CVStrategy should have received tokens
        uint256 cvBalanceAfter = token.balanceOf(address(cvStrategy));
        assertGt(cvBalanceAfter, cvBalanceBefore, "Tokens received");
    }
    
    /*//////////////////////////////////////////////////////////////
                    PROPOSAL DISTRIBUTION TESTS
    //////////////////////////////////////////////////////////////*/
    
    function testYieldDistributedToProposals() public {
        // Create 2 proposals
        uint256 proposalId1 = _createProposal(proposalBeneficiary1, 0);
        uint256 proposalId2 = _createProposal(proposalBeneficiary2, 0);
        
        // Members support proposals with different amounts
        _allocateSupport(proposalId1, 6000, pool_member1()); // 60% support
        _allocateSupport(proposalId2, 4000, pool_member2()); // 40% support
        
        // Generate yield in YDS
        vm.prank(depositor1);
        yds.deposit(10000e18, depositor1);
        
        token.mint(address(yds), 1000e18); // 10% yield
        yds.report();
        
        // Advance blocks so conviction accumulates
        vm.roll(block.number + 1000);
        
        uint256 ben1BalanceBefore = token.balanceOf(proposalBeneficiary1);
        uint256 ben2BalanceBefore = token.balanceOf(proposalBeneficiary2);
        
        // Harvest and distribute
        cvStrategy.harvestYDS();
        
        // Beneficiaries should receive proportional amounts
        uint256 ben1Received = token.balanceOf(proposalBeneficiary1) - ben1BalanceBefore;
        uint256 ben2Received = token.balanceOf(proposalBeneficiary2) - ben2BalanceBefore;
        
        assertGt(ben1Received, 0, "Beneficiary 1 received yield");
        assertGt(ben2Received, 0, "Beneficiary 2 received yield");
        
        // Should be roughly 60/40 split based on conviction
        // (exact ratio depends on conviction accumulation)
        assertGt(ben1Received, ben2Received, "Ben1 should receive more (60% support)");
    }
    
    function testMultipleYieldCycles() public {
        // Create proposal
        uint256 proposalId = _createProposal(proposalBeneficiary1, 0);
        _allocateSupport(proposalId, 10000, pool_member1());
        
        // Setup YDS with deposit
        vm.prank(depositor1);
        yds.deposit(10000e18, depositor1);
        
        uint256 totalReceived = 0;
        
        // Cycle 1: Generate and distribute
        token.mint(address(yds), 100e18);
        yds.report();
        vm.roll(block.number + 100);
        cvStrategy.harvestYDS();
        totalReceived += token.balanceOf(proposalBeneficiary1);
        
        // Cycle 2: More yield
        token.mint(address(yds), 150e18);
        yds.report();
        vm.roll(block.number + 100);
        cvStrategy.harvestYDS();
        totalReceived = token.balanceOf(proposalBeneficiary1) - totalReceived;
        
        // Cycle 3: Even more
        token.mint(address(yds), 200e18);
        yds.report();
        vm.roll(block.number + 100);
        cvStrategy.harvestYDS();
        
        uint256 finalReceived = token.balanceOf(proposalBeneficiary1);
        
        // Should have received yield from all cycles
        assertGt(finalReceived, 400e18, "Should have received from multiple cycles");
    }
    
    function testNoYieldWhenNoDonationShares() public {
        // Create proposal but no yield generated
        uint256 proposalId = _createProposal(proposalBeneficiary1, 0);
        _allocateSupport(proposalId, 10000, pool_member1());
        
        uint256 balanceBefore = token.balanceOf(proposalBeneficiary1);
        
        // Try to harvest (should be no-op)
        cvStrategy.harvestYDS();
        
        uint256 balanceAfter = token.balanceOf(proposalBeneficiary1);
        assertEq(balanceAfter, balanceBefore, "No tokens transferred");
    }
    
    /*//////////////////////////////////////////////////////////////
                        CONVICTION-BASED TESTS
    //////////////////////////////////////////////////////////////*/
    
    function testConvictionAffectsDistribution() public {
        // Create 2 proposals with equal initial support
        uint256 proposalId1 = _createProposal(proposalBeneficiary1, 0);
        uint256 proposalId2 = _createProposal(proposalBeneficiary2, 0);
        
        _allocateSupport(proposalId1, 5000, pool_member1());
        _allocateSupport(proposalId2, 5000, pool_member2());
        
        // Proposal 1 gets more time to accumulate conviction
        vm.roll(block.number + 1000);
        cvStrategy.updateProposalConviction(proposalId1);
        
        // Proposal 2 added later (less conviction)
        vm.roll(block.number + 100);
        cvStrategy.updateProposalConviction(proposalId2);
        
        // Generate yield
        vm.prank(depositor1);
        yds.deposit(10000e18, depositor1);
        token.mint(address(yds), 1000e18);
        yds.report();
        
        // Distribute
        cvStrategy.harvestYDS();
        
        uint256 ben1Received = token.balanceOf(proposalBeneficiary1);
        uint256 ben2Received = token.balanceOf(proposalBeneficiary2);
        
        // Proposal 1 should receive more (higher conviction from longer duration)
        assertGt(ben1Received, ben2Received, "Higher conviction = more yield");
    }
    
    /*//////////////////////////////////////////////////////////////
                            HELPERS
    //////////////////////////////////////////////////////////////*/
    
    function _createProposal(address beneficiary, uint256 requestedAmount) internal returns (uint256) {
        CVParams memory cvParams = CVParams({
            decay: 9965853, // 7-day half-life
            weight: 500000,
            maxRatio: 2000000,
            minThresholdPoints: 100000
        });
        
        // ... implementation would use existing test helpers
        // For now, simplified
        return 1;
    }
    
    function _allocateSupport(uint256 proposalId, uint256 amount, address supporter) internal {
        // ... implementation would use existing allocate helpers
    }
}


